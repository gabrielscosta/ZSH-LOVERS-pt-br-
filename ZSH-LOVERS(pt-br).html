<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<!-- saved from url=(0036)https://grml.org/zsh/zsh-lovers.html -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="generator" content="AsciiDoc 8.6.9">
<title>ZSH-LOVERS(1-pt-br)</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
<h1>ZSH-LOVERS(1 - pt-br)</h1>
</div>
<div id="content">
<div class="sect1">
<h2 id="_name">NOME</h2>
<div class="sectionbody">
<div class="paragraph"><p>zsh-lovers - dicas, truques e exemplos para para a Z shell</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_synopsis">SINOPSE</h2>
<div class="sectionbody">
<div class="paragraph"><p>Somente leia it. ;-)</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_overview">VISÃO GERAL</h2>
<div class="sectionbody">
<div class="paragraph"><p>Seja quando for que olhamos o manual zsh, nos perguntamos por que não há exemplos ou aquelas coisas simples na (shell) vida. A zsh contem muitos recursos, mas não havia 
manpage com alguns exemplos [como procmailex(5)]. Por isso escrevemos essa manpage.</p></div>
<div class="paragraph"><p>A maioria dos truques e oneliner vem das mailinglists dos usuários de zsh,
zsh-workers, google, newsgroups e de nós mesmos. Veja a seção <strong>LINKS</strong> para detalhes.</p></div>
<div class="paragraph"><p>Nota: Essa manpage [zsh-lovers(1)] <strong>não</strong> é uma parte oficial da Z shell! Ela é somente uma - manpage só por prazer ;)<br>
Para comentários, bugreports e feedback dê uma olhada rápida na seção <strong>BUGS</strong>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_shell_scripting">SHELL-SCRIPTING</h2>
<div class="sectionbody">
<div class="paragraph"><p>Essa seção fornece alguns exemplos para coisas de shell script frequentemente necessárias. Aviso prévio você não deve utilizar, de outra forma muitos exemplos não funcionarão.<br>
 Opções parse nos shellscripts. Exemplo retirado do ZWS por Adam Chodorowski
(<a href="http://www.chodorowski.com/projects/zws/">http://www.chodorowski.com/projects/zws/</a>):</p></div>
<div class="listingblock">
<div class="content">
<pre><code>parse_options()
{
    o_port=(-p 9999)
    o_root=(-r WWW)
    o_log=(-d ZWS.log)

    zparseopts -K -- p:=o_port r:=o_root l:=o_log h=o_help
    if [[ $? != 0 || "$o_help" != "" ]]; then
        echo Usage: $(basename "$0") "[-p PORT] [-r DIRECTORY]"
        exit 1
    fi

    port=$o_port[2]
    root=$o_root[2]
    log=$o_log[2]

    if [[ $root[1] != '/' ]]; then root="$PWD/$root"; fi
}
# now use the function:
parse_options $*</code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_examples">EXEMPLOS</h2>
<div class="sectionbody">
<div class="paragraph"><p>As subseções disponíveis são <strong>Aliases</strong>, <strong>Conclusões</strong>, <strong>Exemplos desordenados/Miscelaneas</strong>,
<strong>(Recursive) Exemplos de Globbing</strong>, <strong>Uso de modificadores</strong>, <strong>Exemplos de Redirecionamento</strong>,
<strong>Exemplos de ZMV</strong> e <strong>Exemplos de Módulos</strong>.</p></div>
<div class="sect2">
<h3 id="_aliases">ALIASES</h3>
<div class="paragraph"><p>Suffix aliases são suportadas na zsh desde a versão 4.2.0. Alguns exemplos:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>alias -s tex=vim
alias -s html=w3m
alias -s org=w3m</code></pre>
</div></div>
<div class="paragraph"><p>Agora pressionando a tecla return depois de entrar <em>foobar.tex</em> inicia o vim com 
foobar.tex. Chamando um arquivo html roda o browser w3m. <em>www.zsh.org</em> e pressioando 
enter inicia o w3m com o argumento www.zsh.org.<br>
Aliases globais podem ser utilizadas em qualquer lugar na linha de comnando. Exemplo:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ alias -g C='| wc -l'
$ grep alias ~/.zsh/* C
443</code></pre>
</div></div>
<div class="paragraph"><p>Algumas aliases globais mais ou menos uteis (escolha se elas são uteis ou não para você):</p></div>
<div class="listingblock">
<div class="content">
<pre><code>alias -g ...='../..'
alias -g ....='../../..'
alias -g .....='../../../..'
alias -g CA="2&gt;&amp;1 | cat -A"
alias -g C='| wc -l'
alias -g D="DISPLAY=:0.0"
alias -g DN=/dev/null
alias -g ED="export DISPLAY=:0.0"
alias -g EG='|&amp; egrep'
alias -g EH='|&amp; head'
alias -g EL='|&amp; less'
alias -g ELS='|&amp; less -S'
alias -g ETL='|&amp; tail -20'
alias -g ET='|&amp; tail'
alias -g F=' | fmt -'
alias -g G='| egrep'
alias -g H='| head'
alias -g HL='|&amp; head -20'
alias -g Sk="*~(*.bz2|*.gz|*.tgz|*.zip|*.z)"
alias -g LL="2&gt;&amp;1 | less"
alias -g L="| less"
alias -g LS='| less -S'
alias -g MM='| most'
alias -g M='| more'
alias -g NE="2&gt; /dev/null"
alias -g NS='| sort -n'
alias -g NUL="&gt; /dev/null 2&gt;&amp;1"
alias -g PIPE='|'
alias -g R=' &gt; /c/aaa/tee.txt '
alias -g RNS='| sort -nr'
alias -g S='| sort'
alias -g TL='| tail -20'
alias -g T='| tail'
alias -g US='| sort -u'
alias -g VM=/var/log/messages
alias -g X0G='| xargs -0 egrep'
alias -g X0='| xargs -0'
alias -g XG='| xargs egrep'
alias -g X='| xargs'</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_completion">CONCLUSÃO</h3>
<div class="paragraph"><p>Veja também man 1 zshcompctl zshcompsys zshcompwid. zshcompctl é o estilo antigo da conclusão programável da zsh, zshcompsys é o novo sistema de conclusão, zshcompwid são as novas ferramentas de conclusão.</p></div>
<div class="paragraph"><p>Algumas funções, como _apt e _dpkg, são muito lentas [nota do tradutor: a versão 9 do Debian (codenome Stretch) melhorou a parte de desempenho do sistema tanto no dpkg e apt quanto para colocá-lo em produção após o lançamento oficial estável]. Você pode utilizar um cache a fim de gerar uma lista de resultados (como a lista de pacotes debian disponíveis). Utilize um cache:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>zstyle ':completion:*' use-cache on
zstyle ':completion:*' cache-path ~/.zsh/cache</code></pre>
</div></div>
<div class="paragraph"><p>Evite que arquivos/diretórios de CVS sejam completados:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>zstyle ':completion:*:(all-|)files' ignored-patterns '(|*/)CVS'
zstyle ':completion:*:cd:*' ignored-patterns '(*/)#CVS'</code></pre>
</div></div>
<div class="paragraph"><p>Combinação de concluções para quando você digitar errado:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>zstyle ':completion:*' completer _complete _match _approximate
zstyle ':completion:*:match:*' original only
zstyle ':completion:*:approximate:*' max-errors 1 numeric</code></pre>
</div></div>
<div class="paragraph"><p>E se você quiser o número de erros permitidos pela _approximate para aumentar com a comprimento do que você digitou até agora:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>zstyle -e ':completion:*:approximate:*' \
        max-errors 'reply=($((($#PREFIX+$#SUFFIX)/3))numeric)'</code></pre>
</div></div>
<div class="paragraph"><p>Ignore as funções de conclusão para comando que você não possui:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>zstyle ':completion:*:functions' ignored-patterns '_*'</code></pre>
</div></div>
<div class="paragraph"><p>Com a função helper como:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>xdvi() { command xdvi ${*:-*.dvi(om[1])} }</code></pre>
</div></div>
<div class="paragraph"><p>Você pode evitar ter que completar em muitos casos, mas se você quiser, você pode querer ir parar na seleção do menu imediatamente  e ter as palavras ordenadas por tempo:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>zstyle ':completion:*:*:xdvi:*' menu yes select
zstyle ':completion:*:*:xdvi:*' file-sort time</code></pre>
</div></div>
<div class="paragraph"><p>Completar process IDs como seleção de menu:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>zstyle ':completion:*:*:kill:*' menu yes select
zstyle ':completion:*:kill:*'   force-list always</code></pre>
</div></div>
<div class="paragraph"><p>Se você acabar utilizano um diretório como argumento, isso removerá a trilha (util no ln)</p></div>
<div class="listingblock">
<div class="content">
<pre><code>zstyle ':completion:*' squeeze-slashes true</code></pre>
</div></div>
<div class="paragraph"><p>cd nunca selecionará o diretório pai (ex.: cd ../&lt;TAB&gt;):</p></div>
<div class="listingblock">
<div class="content">
<pre><code>zstyle ':completion:*:cd:*' ignore-parents parent pwd</code></pre>
</div></div>
<div class="paragraph"><p>Outro mpetodo para <em>mudança rápida de diretórios</em>. Adicione isso ao seu ~/.zshrc, depois apenas entre em 
“cd …./dir”</p></div>
<div class="listingblock">
<div class="content">
<pre><code>rationalise-dot() {
  if [[ $LBUFFER = *.. ]]; then
    LBUFFER+=/..
  else
    LBUFFER+=.
  fi
}
zle -N rationalise-dot
bindkey . rationalise-dot</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_unsorted_misc_examples">Exemplos DESORDENADOS/DIVERSOS</h3>
<div class="paragraph"><p>Dica: Uma lista de Qualificadores globais válidos (valid glob Qualifiers) podem ser encontrados em zshexpn(1). Veja “man 1 zshexpn | less -p” Qualifiers para detalhes.</p></div>
<div class="listingblock">
<div class="content">
<pre><code># Get the names of all files that *don't* match a pattern *anywhere* on the
# file (and without ``-L'' because its GNUish)
  $ print -rl -- *(.^e{'grep -q pattern $REPLY'})
  # or
  $ : *(.e{'grep -q pattern $REPLY || print -r -- $REPLY'})

# random numbers
  $ echo $[${RANDOM}%1000]     # random between 0-999
  $ echo $[${RANDOM}%11+10]    # random between 10-20
  $ echo ${(l:3::0:)${RANDOM}} # N digits long (3 digits)

# reverse a word
  $ echo "${(j::)${(@Oa)${(s::):-hello}}}"

# Show newest directory
  $ ls -ld *(/om[1])

# random array element
  $ FILES=( .../files/* )
  $ feh $FILES[$RANDOM%$#FILES+1]

# cat first line in all files in this dir
  $ for file (*(ND-.)) IFS= read -re &lt; $file

# test if a parameter is numeric
  $ if [[ $1 == &lt;-&gt; ]] ; then
         echo numeric
    else
         echo non-numeric
    fi

# Show me all the .c files for which there doesn't exist a .o file.
  $ print *.c(e_'[[ ! -e $REPLY:r.o ]]'_)

# All files in /var/ that are not owned by root
  $ ls -ld /var/*(^u:root)

# All files for which the owner hat read and execute permissions
  $ echo *(f:u+rx:)

# The same, but also others dont have execute permissions
  $ echo *(f:u+rx,o-x:)

# brace expansion - example
  $ X=(A B C)
  $ Y=(+ -)
  $ print -r -- $^X.$^Y
  A.+ A.- B.+ B.- C.+ C.-

# Fetch the newest file containing the string 'fgractg*.log' in the
# filename and contains the string 'ORA-' in it
  $ file=(fgractg*.log(Nm0om[1]))
  $ (($#file)) &amp;&amp; grep -l ORA- $file
  # without Zsh
  $ files=$( find . -name . -o -prune -name 'fgractg*&gt;log' -mtime 0 -print )
  &gt; if [ -n "$files" ]; then
  &gt;    IFS='
  &gt; '
  &gt; set -f
  &gt; file=$(ls -td $files | head -1)
  &gt; grep -l ORA- "$file"
  &gt; fi

# keep specified number of child processes running until entire task finished
  $ zsh -c 'sleep 1 &amp; sleep 3 &amp; sleep 2&amp; print -rl -- $jobtexts'

# Remove zero length and .bak files in a directory
  $ rm -i *(.L0) *.bak(.)

# print out files that dont have extensions
  $ printf '%s\n' ^?*.*
  $ printf '%s\n' ^?*.[^.]*(D)
  $ ls -d -- ^?*.*(D)

# Finding files which does not contain a specific string
  $ print -rl file* | comm -2 -3 - &lt;(grep -l string file*)'
  $ for f (file*(N)) grep -q string $f || print -r $f'

# Show/Check whether a option is set or not. It works both with $options as
# with $builtins
  $ echo $options[correct]
  off
  $ $options[zle]
  on

# Count the number of directories on the stack
  $ print $((${${(z)${(f)"$(dirs -v)"}[-1]}[1]} + 1)) # or
  $ dirs -v | awk '{n=$1}END{print n+1}'

# Matching all files which do not have a dot in filename
  $ ls *~*.*(.)

# Show only the ip-address from ``ifconfig device''
  # ifconfig from net-tools (Linux)
  $ print ${${$(LC_ALL=C /sbin/ifconfig eth0)[7]}:gs/addr://}
  # ifconfig from 4.2BSD {Free,Net,Open}BSD
  $ print ${$(/sbin/ifconfig tun0)[6]}

# Ping all the IP addresses in a couple of class C's or all hosts
# into /etc/hosts
  $ for i in {1..254}; do ping -c 1 192.168.13.$i; done
  or
  $ I=1
  $ while ( [[ $I -le 255 ]] ) ; do ping -1 2 150.150.150.$I; let I++; done
  or
  $ for i in $(sed 's/#.*//' &gt; /etc/hosts | awk '{print $2}')
  : do
  :    echo "Trying $i ... "
  :    ping -c 1 $i ;
  :    echo '============================='
  : done

# load all available modules at startup
  $ typeset -U m
  $ m=()
  $ for md ($module_path) m=($m $md/**/*(*e:'REPLY=${REPLY#$md/}'::r))
  $ zmodload -i $m

# Rename all files within a directory such that their names get a numeral
# prefix in the default sort order.
  $ i=1; for j in *; do mv $j $i.$j; ((i++)); done
  $ i=1; for f in *; do mv $f $(echo $i | \
    awk '{ printf("%03d", $0)}').$f; ((i++)); done
  $ integer i=0; for f in *; do mv $f $[i+=1].$f; done

# Find (and print) all symbolic links without a target within the current
# dirtree.
  $ $ file **/*(D@) | fgrep broken
  $ for i in **/*(D@); [[ -f $i || -d $i ]] || echo $i
  $ echo **/*(@-^./=%p)
  $ print -l **/*(-@)

# List all plain files that do not have extensions listed in `fignore'
  $ ls **/*~*(${~${(j/|/)fignore}})(.)
  # see above, but now omit executables
  $ ls **/*~*(${~${(j/|/)fignore}})(.^*)

# Print out files that dont have extensions (require *setopt extendedglob*
# and *setopt dotglob*)
  $ printf '%s\n' ^?*.*

# List files in reverse order sorted by name
  $ print -rl -- *(On)
  or
  $ print -rl -- *(^on)

# Synonymic to ``ps ax | awk '{print $1}'''
  $ print -l /proc/*/cwd(:h:t:s/self//)

# Get the PID of a process (without ``ps'', ``sed'', ``pgrep'', ..
# (under Linux)
  $ pid2 () {
  &gt;   local i
  &gt;   for i in /proc/&lt;-&gt;/stat
  &gt; do
  &gt;   [[ "$(&lt; $i)" = *\((${(j:|:)~@})\)* ]] &amp;&amp; echo $i:h:t
  &gt; done
  &gt; }

# for X in 'n' 'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y'; do ...
  $ for (( i = 36#n; i &lt;= 36#y; i++ )); do
  &gt;   print ${$(([##36]i)):l}
  &gt; done
# or in combination with ``dc''
  $ print {$((##n))..$((##y))}P\ 10P | dc
# or with ``eval''
  $ eval print '${$(([##36]'{$((36#n))..$((36#y))}')):l}'

# foreach in one line of shell
  $ for f (*) print -r -- $f

# copy a directory recursively without data/files
  $ dirs=(**/*(/))
  $ cd -- $dest_root
  $ mkdir -p -- $dirs
# or without zsh
  $ find . -type d -exec env d="$dest_root" \
    sh -c ' exec mkdir -p -- "$d/$1"' '{}' '{}' \;

# If `foo=23'', then print with 10 digit with leading '0'.
  $ foo=23
  $ print ${(r:10::0:)foo}

# find the name of all the files in their home directory that have
# more than 20 characters in their file names
  print -rl $HOME/${(l:20::?:)~:-}*

# Save arrays
  $ print -r -- ${(qq)m} &gt; $nameoffile      # save it
  $ eval "m=($(cat -- $nameoffile)"            # or use
  $ m=("${(@Q)${(z)"$(cat -- $nameoffile)"}}") # to restore it

# get a "ls -l" on all the files in the tree that are younger than a
# specified age (e.g "ls -l" all the files in the tree that where
# modified in the last 2 days)
  $ ls -tld **/*(m-2)
# This will give you a listing 1 file perl line (not à la ls -R).
# Think of an easy way to have a "ls -R" style output with
# only files newer than 2 day old.
  $ for d (. ./**/*(/)) {
  &gt;   print -r -- $'\n'${d}:
  &gt;   cd $d &amp;&amp; {
  &gt;       l=(*(Nm-2))
  &gt;       (($#l)) &amp;&amp; ls -ltd -- $l
  &gt;       cd ~-
  &gt;   }
  &gt; }
# If you also want directories to be included even if their mtime
# is more than 2 days old:
  $ for d (. ./**/*(/)) {
  &gt;   print -r -- $'\n'${d}:
  &gt;   cd $d &amp;&amp; {
  &gt;      l=(*(N/,m-2))
  &gt;      (($#l)) &amp;&amp; ls -ltd -- $l
  &gt;      cd ~-
  &gt;   }
  &gt; }
# And if you want only the directories with mtime &lt; 2 days to be listed:
  $ for d (. ./**/*(N/m-2)) {
  &gt;   print -r -- $'\n'${d}:
  &gt;   cd $d &amp;&amp; {
  &gt;      l=(*(Nm-2))
  &gt;      (($#l)) &amp;&amp; ls -ltd -- $l
  &gt;      cd ~-
  &gt;   }
  &gt; }

# print 42 ``-''
  $ echo ${(l:42::-:)}
# or use ``$COLUMS''
  $ echo ${(l:$COLUMNS::-:)}
# and now with colors (require autoload colors ;colors)
  $ echo "$bg[red]$fg[black]${(l:42::-:)}"

# Redirect STDERR to a command like xless without redirecting STDOUT as well.
  $ foo 2&gt;&gt;(xless)
# but this executes the command asynchronously. To do it synchronously:
  $ { { foo 1&gt;&amp;3 } 2&gt;&amp;1 | xless } 3&gt;&amp;1

# Rename all MP3-Files from name with spaces.mp3 to Name With Spaces.mp3
  $ for i in *.mp3; do
  &gt;     mv $i ${${(C)i}:s/Mp3/mp3/}
  &gt; done

# Match file names containing only digits and ending with .xml (require
# *setopt kshglob*)
  $ ls -l [0-9]##.xml
  $ ls -l &lt;0-&gt;.xml

# Remove all "non txt" files
  $ rm ./^*.txt

# Move 200 files from a directory into another
  $ mv -- *([1,200]) /another/Dir

# Convert images (foo.gif =&gt; foo.png):
  $ for i in **/*.gif; convert $i $i:r.png

# convert a collection of mp3 files to wave or cdr,
# e.g. file.wav -&gt; file.mp3)
  $ for i (./*.mp3){mpg321 --w - $i &gt; ${i:r}.wav}

# Download with LaTeX2HTML  created Files (for example the ZSH-Guide):
  $ for f in http://zsh.sunsite.dk/Guide/zshguide{,{01..08}}.html; do
  &gt;     lynx -source $f &gt;${f:t}
  &gt; done

# Move all files in dir1 and dir2 that have line counts greater than 10 to
# another directory say "/more10"
  $ mv dir[12]/**/*.cr(-.e{'((`wc -l &lt; $REPLY` &gt; 10))'}) /more10

# Make with dpkg a master-list of everyfile that it has installed
  $ diff &lt;(find / | sort) &lt;(cat /var/lib/dpkg/info/*.list | sort)

# Replace this fucking Escape-Sequences:
  $ autoload colors ; colors
  $ print "$bg[cyan]$fg[blue]You are a idiot" &gt;&gt; /dev/pts/3

# Get ASCII value of a character
  $ char=N ; print $((#char))

# Filename "Erweiterung"
# Note: The (N) says to use the nullglob option for this particular
# glob pattern.
  $ for i in *.o(N); do
  &gt;     rm $i
  &gt; done

# Rename files; i. e. FOO to foo and bar to BAR
  $ for i in *(.); mv $i ${i:l} # `FOO' to `foo'
  $ for i in *(.); mv $i ${i:u} # `bar to `BAR'

# Show all suid-files in $PATH
  $ ls -latg ${(s.:.)PATH} | grep '^...s'
# or more complex ;)
  $ print -l ${^path}/*(Ns,S)
# or show only executables with a user given pattern
  $ print -l ${^path}/*vim*(*N)

# gzip files when containing a certain string
  $ gzip ${(ps:\0:)"$(grep -lZ foobar ./*.txt(.))"}

# A small  one-liner, that reads from stdin and prints to stdout the first
# unique line i. e. does not print lines that have been printed before
# (this is similar to the unique command, but unique can only handle
# adjacent lines).
  $ IFS=$'\n\n'; print -rl -- ${(Oau)${(Oa)$(cat file;echo .)[1,-2]}}

# Lists every executable in PATH
  $ print -l ${^path}/*(-*N)

# Match all .c files in all subdirectories, _except_ any SCCS subdirectories?
  $ ls **/*.c~(*/)#SCCS/*

# List all `README' - files case-insensitive with max. one typo
  $ ls **/*(#ia2)readme

# case insensitive checking for variables
  $ if [[ $OSTYPE == (#i)LINUX*(#I) ]]; then
  &gt;    echo "Penguin on board."
  &gt; else
  &gt;    echo "Not a Linux."
  &gt; fi</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_recursive_globbing_examples">Exemplos de Globbing (Recursivos)</h3>
<div class="paragraph"><p>Uma lisra de valid glob Qualifiers podem ser encontrados em zshexpn(1). <strong>Nota:</strong>
**/ é equivalente a (*/)#! Por exemplo:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ print (*/)#zsh_us.ps
zsh-4.2.3/Doc/zsh_us.ps
$ print **/zsh_us.ps
zsh-4.2.3/Doc/zsh_us.ps</code></pre>
</div></div>
<div class="listingblock">
<div class="content">
<pre><code># Search for `README' in all Subdirectories
  $ ls -l **/README

# find directories that contain both "index.php" and "index.html", or in
# general, directories that contain more than one file matching "index.*"
  $ ls **/*(D/e:'[[ -e $REPLY/index.php &amp;&amp; -e $REPLY/index.html ]]':)
  # or
  $ ls **/*(D/e:'l=($REPLY/index.*(N)); (( $#l &gt;= 2 ))':)

# Find command to search for directory name instead of basename
  $ print -rl /**/*~^*/path(|/*)
  # or - without Zsh
  $ find / | grep -e /path/ -e '/path$'

# Print he path of the directories holding the ten biggest C regular files
# in the current directory and subdirectories.
  $ print -rl -- **/*.c(D.OL[1,10]:h) | sort -u

# Find files with size == 0 and send a mail
  $ files=(**/*(ND.L0m+0m-2))
  &gt; (( $#files &gt; 0 )) &amp;&amp; print -rl -- $files | \
    mailx -s "empty files" foo@bar.tdl

# recursive chmod
  $ chmod 700 **/(.) # Only files
  $ chmod 700 **/(/) # Only directories

# print out all of the files in that directory in 2 columns
  $ print -rC2 -- ${1:[...]}/*(D:t)
#            ^- number ob columns
# or - if you feel concerned about special characters - use
  $ list=(${1:[...]}/*(ND:t))
  $ (($#list)) &amp;&amp; print -rC2 -- ${(V)list}

# Search all files in /home/*/*-mail/ with a setting ``chmod -s'' flag
# (recursive, include  dotfiles) remove the setgid/setuid flag and print
# a message
  $ chmod -s /home/*/*-mail(DNs,S) /home/*/*-mail/**/*(DNs,S))
# or with a small script
  $ for file (/home/*/*-mail(DNs,S) /home/*/*-mail/**/*(DNs,S)) {
  &gt;    print -r -- $file
  &gt;    chmod -s $file &amp;&amp; print -r fixed $file
  &gt; }
# or use ``zargs'' (require autoload zargs) prevent the arg list too
# long error
  $ zargs /home/*/*-mail(DNs,S) /home/*/*-mail/**/*(DNs,S)) -- chmod -s

# List files beginning at `foo23' upwards (foo23, foo24, foo25, ..)
  $ ls -l foo&lt;23-&gt;

# get all files that begin with the date strings from June 4 through
# June 9 of 2004
  $ ls -l 200406{04..10}*(N)
# or if they are of the form 200406XX (require ``setopt extended_glob''
  $ ls -l 200306&lt;4-10&gt;.*

# remove spaces from filenames
  $ for a in ./**/*\ *(Dod); do mv $a ${a:h}/${a:t:gs/ /_}; done

# Show only all *.c and *.h - Files
  $ ls -l *.(c|h)

# Show only all *.c - files and ignore `foo.c'
  $ ls *.c~foo.c

# show data to *really* binary format
  $ zsh -ec 'while {} {printf %.8x $n;repeat 8 \
  &gt; {read -ku0 a printf \ %.8d $(([##2]#a))};print;((n+=8))}' &lt; binary

# Show only world-readable files
  $ ls -l *(R)

# List files in the current directory are not writable by the owner
  $ print -l ~/*(ND.^w)

# find and delete the files which are older than a given parameter
# (seconds/minutes/hours)
  # deletes all regular file in /Dir that are older than 3 hours
   $ rm -f /Dir/**/*(.mh+3)
  # deletes all symlinks in /Dir that are older than 3 minutes
   $ rm -f /Dir/**/*(@mm+3)
  # deletes all non dirs in /Dir that are older than 30 seconds
   $ rm -f /Dir/**/*(ms+30^/)
  # deletes all folders, sub-folders and files older than one hour
   $ rm ./**/*(.Dmh+1,.DL0)
  # deletes all files more than 6 hours old
   $ rm -f **/*(mh+6)
  # removes all files but the ten newer ones (delete all but last 10
  # files in a directory)
   $ rm ./*(Om[1,-11])
 Note: If you get a arg list too long, you use the builtin rm. For
       example:
   $ zmodload zsh/files ; rm -f **/*(mh+6)
  or use the zargs function:
   $ autoload zargs ; zargs **/*(mh+6) -- rm -f

# A User's Guide to the Z-Shell /5.9: Filename Generation and Pattern
# Matching find all files in all subdirectories, searching recursively,
# which have a given name, case insensitive, are at least 50 KB large,
# no more than a week old and owned by the root user, and allowing up
# to a single error in the spelling of the name. In fact, the required
# expression looks like this:
  $ ls **/(#ia1)name(LK+50mw-1u0)

# Change the UID from 102 to 666
  $ chown 666 **/*(u102)

# List all files which have not been updated since last 10 hours
  $ print -rl -- *(Dmh+10^/)

# delete only the oldest file in a directory
  $ rm ./*filename*(Om[1])

# Sort the output from `ls -l' by file size
  $ ls -fld *(OL)

# find most recent file in a directory
  $ setopt dotglob ; print directory/**/*(om[1])

# Show only empty files which nor `group' or `world writable'
  $ ls *(L0f.go-w.)

# Find - and list - the ten newest files in directories and subdirs.
# (recursive)
  $ print -rl -- **/*(Dom[1,10])

# Print only 5 lines by "ls" command (like ``ls -laS | head -n 5'').
  $ ls -fl *(DOL[1,5])

# Display the 5-10 last modified files.
  $ print -rl -- /path/to/dir/**/*(D.om[5,10])

# Find all files without a valid owner.
  $ chmod someuser /**/*(D^u:${(j.:u:.)${(f)"$(&lt;/etc/passwd)"}%%:*}:)

# Find all the empty directories in a tree.
  $ for f in ***/*(/l2); do foo=($f/*(N)); [[ -z $foo ]] &amp;&amp; print $f; done
# Note:Since Zsh 4.2.1 the glob qualifier F indicates a non-empty directory.
# Hence *(F) indicates all subdirectories with entries, *(/^F) means all
# subdirectories with no entries.
  $ ls -ld *(/^F)

# Remove empty directories afterwards.
  $ rmdir ./**/*(/od) 2&gt; /dev/null

# Show only files which are owned by group `users'.
  $ ls -l *(G[users])</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_modifiers_usage">Uso de modificadores</h3>
<div class="paragraph"><p>Modificadores são um poderoso mecanismo que lhe permite modificar os resultados retornados pela expanção de parametro, filename e history. Veja zshexpn(1)
 para detalhes.</p></div>
<div class="listingblock">
<div class="content">
<pre><code># NOTE: Zsh 4.3.4 needed!
  $ autoload -U age
# files modified today
  $ print *(e:age today now:)
# files modified since 5 pm
  $ print *(e-age 17:00 now-)
# ... since 5 o'clock yesterda
  $ print *(e-age yesterday,17:00 now-)
# ... from last Christmas before today
  $ print *(e-age 2006/12/25 today-)
# ... before yesterday
  $ print *(e-age 1970/01/01 yesterday-)
# all files modified between the start of those dates
  $ print *(e:age 2006/10/04 2006/10/09:)
# all files modified on that date
  $ print *(e:age 2006/10/04:)
# Supply times.
  $ print *(e-age 2006/10/04:10:15 2006/10/04:10:45-)

# Remove a trailing pathname component, leaving the head. This works like
# `dirname'.
  $ echo =ls(:h)
  /bin

# Remove all leading pathname components, leaving the tail. This works
# like `basename'.
  $ echo =ls(:t)
  ls

# Remove the suffix from each file (*.sh in this example)
   $f:e is $f file extension
   :h --&gt; head (dirname)
   :t --&gt; tail (basename)
   :r --&gt; rest (extension removed)
  $ for f (*.sh) mv $f $f:r

# Remove a filename extension of the form `.xxx', leaving the root name.
  $ echo $PWD
  /usr/src/linux
  $ echo $PWD:t
  linux

# Remove all but the extension.
  $ foo=23.42
  $ echo $foo
  23.42
  $ echo $foo:e
  42

# Print the new command but do not execute it. Only works with history
# expansion.
  $ echo =ls(:h)
  /bin
  $ !echo:p
  $ echo =ls(:h)

# Quote the substituted words, escaping further substitutions.
  $ bar="23'42"
  $ echo $bar
  23'42
  $ echo $bar:q
  23\'42

# Convert the words to all lowercase.
  $ bar=FOOBAR
  $ echo $bar
  FOOBAR
  $ echo $bar:l
  foobar

# Convert the words to all uppercase.
  $ bar=foobar
  $ echo $bar
  foobar
  $ echo $bar:u
  FOOBAR

# convert 1st char of a word to uppercase
  $ foo="one two three four"
  $ print -r -- "${(C)foo}"
  One Two Three Four</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_redirection_examples">Redirecionamento-Exemplos</h3>
<div class="paragraph"><p>Veja zshmisc(1) para maiores informações (ou less ${^fpath}/zmv(N))</p></div>
<div class="listingblock">
<div class="content">
<pre><code># Append `exit 1' at the end of all *.sh - files
  $ echo "exit 1" &gt;&gt; *.sh

# adding files to foobar.tar.gz
  $ eval set =(gunzip &lt; foobar.tar.gz) '
     tar rf $1 additional.txt &amp;&amp;gzip &lt; $1 &gt; foobar.tar.gz'

# Redirect output to a file AND display on screen
  $ foobar &gt;&amp;1 &gt; file1 &gt; file2 &gt; ..

# pipe single output to multiple inputs
  $ zcat foobar.Z &gt;&gt; (gzip -9 &gt; file1.gz) \
      &gt;&gt; (bzip2 -9 &gt; file1.bz2) \
      &gt;&gt; (acb --best &gt; file1.acb)

# Append /etc/services at the end of file `foo' and `bar'
  $ cat /etc/services &gt;&gt; foo &gt;&gt; bar

# Pipe STDERR
  $ echo An error &gt;&amp;2 2&gt;&amp;1 | sed -e 's/A/I/'

# send standard output of one process to standard input of several processes
# in the pipeline
  $ setopt multios
  $ process1 &gt; &gt;(process1) &gt; &gt;(process2)

# initializing a variable and simultaneously keeping terminal output
  $ setopt multios
  $ { a=$(command &gt;&amp;1 &gt;&amp; 3 3 &gt; &amp;- 2&gt;&amp;1);} 3&gt;&amp;1

# redirect stderr two times
  $ setopt multios ; program 2&gt; file2 &gt; file1 2&gt;&amp;1

# Duplicating stdout and stderr to a logfile
  $ exec 3&gt;&amp;1 &gt; logfile 2&gt;&amp;2 2&gt;&amp;1 &gt;&amp;3 3&gt;&amp;-

# redirect stderr (only) to a file and to orig. stderr:
  $ command 2&gt;&amp;2 2&gt;stderr
# redirect stderr and stdout to separate files and both to orig. stdout:
  $ command 2&gt;&amp;1 1&gt;&amp;1 2&gt;stderr 1&gt;stdout
# redirect stderr and stdout to separate files and stdout to orig. stdout
# AND stderr to orig. stderr:
  $ command 2&gt;&amp;2 1&gt;&amp;1 2&gt;stderr 1&gt;stdout

# More fun with STDERR ;)
  $ ./my-script.sh 2&gt; &gt;(grep -v moron &gt;error.log)|process-output &gt;output.log
  $  echo "Thats STDOUT" &gt;&gt;(sed 's/stdout/another example/' &gt; foobar)</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_zmv_examples_require_autoload_zmv">Exemplos de ZMV (requer autoload zmv)</h3>
<div class="paragraph"><p><strong>Nota:</strong> <em>-n</em> significa sem execução (apenas imprime o que aconteceria). Em</p></div>
<div class="listingblock">
<div class="content">
<pre><code># Remove illegal characters in a fat32 file system. Illegal characters are
#   / :  ;  *  ?  "  &lt;  &gt;  |
# NOTE: ``-Q'' and (D) is to include hidden files.
  $ unwanted='[:;*?\"&lt;&gt;|]'
  $ zmv -Q "(**/)(*$~unwanted*)(D)" '$1${2//$~unwanted/}'

# Changing part of a filename (i. e. "file-hell.name" -&gt; "file-heaven.name")
  $ zmv '(*)hell(*)' '${1}heaven${2}'
  # or
  $ zmv '*' '$f:s/hell/heaven/'

# remove round bracket within filenames
# i. e. foo-(bar).avi -&gt; foo-bar.avi
  $ zmv '*' '${f//[()]/}'

# serially all files (foo.foo &gt; 1.foo, fnord.foo &gt; 2.foo, ..)
  $ autoload zmv
  $ ls *
  1.c  asd.foo  bla.foo  fnord.foo  foo.fnord  foo.foo
  $ c=1 zmv '*.foo' '$((c++)).foo'
  $ ls *
  1.c  1.foo  2.foo  3.foo  4.foo  foo.fnord

# Rename "file.with.many.dots.txt" by substituting dots (exept for the last
# one!) with a space
  $ touch {1..20}-file.with.many.dots.txt
  $ zmv '(*.*)(.*)' '${1//./ }$2'

# Remove the first 4 chars from a filename
  $ zmv -n '*' '$f[5,-1]' # NOTE: The "5" is NOT a mistake in writing!

# Rename names of all files under the current Dir to lower case, but keep
# dirnames as-is.
  $ zmv -Qv '(**/)(*)(.D)' '$1${(L)2}'

# replace all 4th character, which is "1",  with "2" and so on
  $ autoload -U zmv
  $ zmv '(???)1(???[1-4].txt)' '${1}2${2}'

# Remove the first 15 characters from a string
  $ touch 111111111111111{a-z}
  $ autoload zmv
  $ zmv '*' '$f[16,-1]'

# Replace spaces (any number of them) with a single dash in file names
  $ autload zmv
  $ zmv -n '(**/)(* *)' '$1${2//( #-## #| ##)/-}'
  # or - with Bash
  $ find . -depth -name '* *' -exec bash -c '
  &gt; shopt -s extglob
  &gt; file=$1
  &gt; dir=${file%/*}
  &gt; name=${file##*/}
  &gt; newname=${name//*([ -]) *([ -])/-}
  &gt; mv -i -- "$file" "$Dir/$newname"' {} {} \;

# Clean up file names and remove special characters
  $ autoload zmv
  $ zmv -n '(**/)(*)' '$1${2//[^A-Za-z0-9._]/_}'

# Add *.py to a bunch of python scripts in a directory (some of them end
# in *.py and give them all a proper extension
  $ autoload zmv
  $ zmv -n '(**/)(con*)(#qe,file $REPLY | grep "python script",)' '$1$2.py'

# lowercase all extensions (i. e. *.JPG) incl. subfolders
  $ autoload zmv
  $ zmv '(**/)(*).(#i)jpg' '$1$2.jpg'
  # Or - without Zsh
  $ find Dir -name '*.[jJ][pP][gG]' -print | while read f
  &gt; do
  &gt;      case $f in
  &gt;       *.jpg) ;
  &gt;       *) mv "$f" "${f%.*}.jpg" ;
  &gt;       esac
  &gt; done

# remove leading zeros from file extension
  $ autoload zmv
  $ ls
  filename.001  filename.003  filename.005  filename.007  filename.009
  filename.002  filename.004  filename.006  filename.008  filename.010
  $ zmv '(filename.)0##(?*)' '$1$2'
  $ ls
  filename.1  filename.10  filename.2  filename.3  filename.4  filename.5 ..

# renumber files.
  $ autoload zmv
  $ ls *
  foo_10.jpg  foo_2.jpg  foo_3.jpg  foo_4.jpg  foo_5.jpg  foo_6.jpg ..
  $ zmv -fQ 'foo_(&lt;0-&gt;).jpg(.nOn)' 'foo_$(($1 + 1)).jpg'
  $ ls *
  foo_10.jpg  foo_11.jpg  foo_3.jpg  foo_4.jpg  foo_5.jpg  ...

# adding leading zeros to a filename (1.jpg -&gt; 001.jpg, ..
  $ autoload zmv
  $ zmv '(&lt;1-&gt;).jpg' '${(l:3::0:)1}.jpg'

# See above, but now only files with a filename &gt;= 30 chars
  $ autoload zmv
  $ c=1 zmv "${(l:30-4::?:)}*.foo" '$((c++)).foo'

# Replace spaces in filenames with a underline
  $ autoload zmv
  $ zmv '* *' '$f:gs/ /_'

# Change the suffix from *.sh to *.pl
  $ autoload zmv
  $ zmv -W '*.sh' '*.pl'

# Add a "".txt" extension to all the files within ${HOME}
  # ``-.'' is to only rename regular files or symlinks to regular files,
  # ``D'' is to also rename hidden files (dotfiles))
  $ autoload zmv
  $ zmv -Q '/home/**/*(D-.)' '$f.txt'
  # Or to only rename files that don't have an extension:
  $ zmv -Q '/home/**/^?*.*(D-.)' '$f.txt'

# Recursively change filenames with characters ? [ ] / = + &lt; &gt; ; : " , - *
  $ autoload zmv
  $ chars='[][?=+&lt;&gt;;",*-]'
  $ zmv '(**/)(*)' '$1${2//$~chars/%}'

# Removing single quote from filenames (recursively)
  $ autoload zmv
  $ zmv -Q "(**/)(*'*)(D)" "\$1\${2//'/}"

# When a new file arrives (named file.txt) rename all files in order to
# get (e. g. file119.txt becomes file120.txt, file118.txt becomes
# file119.txt and so on ending with file.txt becoming file1.txt
  $ autoload zmv
  $ zmv -fQ 'file([0-9]##).txt(On)' 'file$(($1 + 1)).txt'

# lowercase/uppercase all files/directories
  $ autoload zmv
  $ zmv '(*)' '${(L)1}' # lowercase
  $ zmv '(*)' '${(U)1}' # uppercase

# Remove the suffix *.c from all C-Files
  $ autoload zmv
  $ zmv '(*).c' '$1'

# Uppercase only the first letter of all *.mp3 - files
  $ autoload zmv
  $ zmv '([a-z])(*).mp3' '${(C)1}$2.mp3'

# Copy the target `README' in same directory as each `Makefile'
  $ autoload zmv
  $ zmv -C '(**/)Makefile' '${1}README'

# Removing single quote from filenames (recursively)
  $ autoload zmv
  $ zmv -Q "(**/)(*'*)(D)" "\$1\${2//'/}"

# Rename pic1.jpg, pic2.jpg, .. to pic0001.jpg, pic0002.jpg, ..
  $ autoload zmv
  $ zmv 'pic(*).jpg' 'pic${(l:4::0:)1}.jpg'
  $ zmv '(**/)pic(*).jpg' '$1/pic${(l:4::0:)2}.jpg' # recursively</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_module_examples">Exemplos de Módulos</h3>
<div class="paragraph"><p>Por favor, leia a zshmodules(1) primeiro!</p></div>
<div class="sect3">
<h4 id="_zsh_pcre_require_zmodload_zsh_pcre">zsh/pcre (requer zmodload zsh/pcre)</h4>
<div class="listingblock">
<div class="content">
<pre><code># Copy files of a certain period (date indicated in the filenames)
  $ zmodload zsh/pcre
  $ ls -d -- *(e:'[[ $REPLY -pcre-match pcre-regexp ]]':)
  # or
  $ m() { [[ $1 -pcre-match pcre-regexp ]] }
  $ ls -d -- *(+m)</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_zsh_clone_require_zmodload_zsh_clone">zsh/clone (requer zmodload zsh/clone)</h4>
<div class="listingblock">
<div class="content">
<pre><code># Creates a forked instance of the current shell ($! is set to zero) and
# execute ``command'' on /dev/tty8 (for this example).
  $ zmodload zsh/clone
  $ clone /dev/tty8 &amp;&amp; (($! == 0)) &amp;&amp; exec command</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_zsh_datetime_require_zmodload_zsh_datetime">zsh/datetime (requer zmodload zsh/datetime)</h4>
<div class="listingblock">
<div class="content">
<pre><code>  $ zmodload zsh/datetime
  $ alias datereplacement='strftime "%Y-%m-%d" $EPOCHSECONDS'
  $ export DATE=`datereplacement`
  $ echo $DATE

#  strip date from filename
  $ $ zmodload zsh/datetime
  $ setopt extendedglob
  $ touch aaa_bbb_20041212_c.dat eee_fff_20051019_g.dat
  $ strftime -s pattern \
    '???_???_&lt;0-%Y%m%d&gt;_?.dat' $((EPOCHSECONDS - 365 * 24 * 60 * 60 / 2))
  $ print -rl -- $~pattern
  aaa_bbb_20041212_c.dat
  $ print -rl -- $pattern
  ???_???_&lt;0-20050815&gt;_?.dat

# Search files size == 0, to be based on the file name containing a date
# rather than the "last modified" date of the file
  $ zmodload -i zsh/datetime
  $ strftime -s file "abc_de_%m%d%Y.dat" $((EPOCHSECONDS - 24 * 60 * 60 ))
  $ files=(**/$file(N.L0))
  $ (( $#files &gt; 0 )) &amp;&amp; print -rl -- $files | \
    mailx -s "empty files"  foo@bar.tdl</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_zsh_stat_require_zmodload_zsh_stat">zsh/stat (requer zmodload zsh/stat)</h4>
<div class="listingblock">
<div class="content">
<pre><code># test if a symbolic link links to a certain file
  $ zmodload -i zsh/stat
  $ ! stat -LH s foo.ln || [[ $s[link] != "foo.exe" ]] || ln -sf foo.exe foo.ln

# comparing file dates
  $ zmodload zsh/stat
  $ file1=foo
  $ file2=bar
  $ touch bar &amp; sleep 5 &amp; touch foo
  $ echo $file1 is $(($(stat +mtime $file2) - \
    $(stat +mtime $file1))) seconds older than $file2.
  bar is 5 seconds older than foo

# list the files of a disk smaller than some other file
  $ zmodload zsh/stat
  $ stat -A max +size some-other-file
  $ print -rl ./**/*(D.L-$max)

# List the top 100 biggest files in a disk
  $ zmodload zsh/stat
  $ ls -fld ./**/*(d`stat +device .`OL[1,100])

# Get only the user name and the file names from (like
# ls -l * | awk '{print $3" " $8}')
  $ zmodload zsh/stat
  $ for file; do
  &gt;   stat -sA user +uid -- "$file" &amp;&amp;
  &gt;     print -r -- "$user" "$file"
  &gt; done

# get the difference between actual bytes of file and allocated bytes of file
  $ zmodload zsh/stat
  $ print $(($(stat +block -- file) * 512 - $(stat +size -- file)))

# Find largest file
# ``D''  : to include dot files (d lowercase is for device)
# ``O''  : reverse Ordered (o lowercase for non-reverse order)
# ``L''  : by file Length (l is for number of links)
# ``[1]'': return only first one
  $ zmodload zsh/stat
  $ stat +size ./*(DOL[1])

# file size in bytes
  $ zmodload zsh/stat
  $ stat -L +size ~/.zshrc
  4707

# Delete files in a directory that hasn't been accessed in the last ten days
# and send ONE mail to the owner of the files informing him/her of the files'
# deletion.
  $ zmodload zsh/stat zsh/files
  $ typeset -A f; f=()
  $ rm -f /path/**/*(.a+10e{'stat -sA u +uidr $REPLY; f[$u]="$f[$u]$REPLY"'})
  $ for user (${(k)f}) {print -rn $f[$user]|mailx -s "..." $user}

# Get a "ls -l" on all the files in the tree that are younger than a
# specified age
  $ zmodload zsh/stat
  $ for d (. ./**/*(N/m-2))
  &gt;   print -r -- $'\n'$d: &amp;&amp; cd $d &amp;&amp; {
  &gt;      for f (*(Nm-2om))
  &gt;   stat -F '%b %d %H:%M' -LsAs -- $f &amp;&amp;
  &gt;   print -r -- $s[3] ${(l:4:)s[4]} ${(l:8:)s[5]} \
  &gt;   ${(l:8:)s[6]} ${(l:8:)s[8]} $s[10] $f ${s[14]:+-&gt; $s[14]}
  &gt;   cd ~-
  &gt; }

# get file creation date
  $ zmodload zsh/stat
  $ stat -F '%d %m %Y' +mtime ~/.zshrc
  30 06 2004
  $ stat -F '%D' +mtime ~/.zshrc
  06/30/04</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_zsh_files_require_zmodload_zsh_files">zsh/files (requer zmodload zsh/files)</h4>
<div class="listingblock">
<div class="content">
<pre><code># search a directory for files containing a certain string then copy those
# files to another directory.
  $ zmodload zsh/files
  $ IFS=$'\0'
  $ cp $(grep -lZr foobar .) otherdirectory</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_zsh_mapfile_require_zmodload_zsh_mapfile">zsh/mapfile (requer zmodload zsh/mapfile)</h4>
<div class="listingblock">
<div class="content">
<pre><code># grepping for two patterns
  $ zmodload zsh/mapfile
  $ pattern1="foo"
  $ pattern2="bar foo"
  $ print -l ./**/*(DN.e{'z=$mapfile[$REPLY] &amp;&amp; [[ $z = *$pattern1* &amp;&amp; \
    $z = *$pattern2* ]]'})
# or a solution in combination with zsh/pcre
  $ zmodload -i zsh/mapfile zsh/pcre
  $ pattern1="foo"
  $ pattern2="bar foo"
  $ pcre_compile "(?s)(?=.*?$pattern1).*?$pattern2"
  $ pcre_study
  $ print -l ./**/*(DN.e{'pcre_match $mapfile[$REPLY]'})

# equivalent for ``less /etc/passwd | grep -v root''
  $ zmodload zsh/mapfile
  $ IFS=$'\n\n'
  $ print -rl -- ${${=mapfile[/etc/passwd]}:#*root*}
# or - for case insensitive
  $ setopt extendedglob
  $ print -rl -- ${${=mapfile[/etc/passwd]}:#*(#i)root*}

# If a XML-file contains stuff like ``&lt;TAGA/&gt;'' and ``&lt;TAGB/&gt;'', number
# this empty tags (ones ending in '/&gt;') so if encountered in the same
# order, the preceeding tags would become ``&lt;TAGA/&gt;1&lt;/TAGA&gt;'' and
# ``&lt;TAGB/&gt;2&lt;/TAGB&gt;''
  $ zmodload zsh/mapfile
  $ cnt=0
  $ apfile[data.xml.new]=${(S)mapfile[data.xml]//\
  &gt; (#im)&lt;TAGA&gt;*&lt;\/TAGA&gt;/&lt;TAGA&gt;$((++cnt))&lt;\/TAGA&gt;}

# removing all files in users Maildir/new that contain ``filename="gone.src''
  $ zmodload zsh/{files,mapfile}
  $ rm -f /u1/??/*/Maildir/new/100*(.e{'[[ $mapfile[$REPLY] == \
    *filename=\"gone.scr\"* ]]'})

# Grep out the Title from a postscript file and append that value to the
# end of the filename
  $ autoload -U zmv
  $ zmodload zsh/mapfile
  $ zmv '(*).ps' '$1-${${${mapfile[$f]##*%%Title: }%% *}//[^a-zA-Z0-9_]/}.ps'</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_zsh_mathfunc_require_zmodload_zsh_mathfunc">zsh/mathfunc (requer zmodload zsh/mathfunc)</h4>
<div class="listingblock">
<div class="content">
<pre><code>$ zmodload zsh/mathfunc
$ echo $(( sin(1/4.0)**2 + cos(1/4.0)**2 - 1 ))
  -1.1102230246251565e-16
$ echo $(( pi = 4.0 * atan(1.0) ))
  3.1415926535897931
$ echo $(( f = sin(0.3) ))
  0.29552020666133955
$ print $((1e12 * rand48()))
  847909677310.23413
$ print $(( rand48(seed) ))
  0.01043488334700271</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_zsh_termcap_require_zmodload_zsh_termcap">zsh/termcap (requer zmodload zsh/termcap)</h4>
<div class="listingblock">
<div class="content">
<pre><code> $ zmodload -ab zsh/termcap echotc
 $ GREEN=`echotc AF 2`
 $ YELLOW=`echotc AF 3`
 $ RED=`echotc AF 1`
 $ BRIGHTRED=`echotc md ; echotc AF 1`
 $ print -l ${GREEN}green ${YELLOW}yellow ${RED}red ${BRIGHTRED}brightred</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_zsh_zpty_require_zmodload_zsh_zpty">zsh/zpty (requer zmodload zsh/zpty)</h4>
<div class="listingblock">
<div class="content">
<pre><code>  $ zmodload zsh/zpty
  $ zpty PW passwd $1
  $ zpty PW passwd $1
# ``-r'': read the output of the command name.
# ``z'' : Parameter
  $ zpty -r PW z '*password:'
# send the to command name the given strings as input
  $ zpty -w PW $2
  $ zpty -r PW z '*password:'
  $ zpty -w PW $2
# The second form, with the -d option, is used to delete commands
# previously started, by supplying a list of their names. If no names
# are given, all commands are deleted. Deleting a command causes the HUP
# signal to be sent to the corresponding process.
  $ zpty -d PW</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_zsh_net_socket_require_zmodload_zsh_net_socket">zsh/net/socket (requer zmodload zsh/net/socket)</h4>
<div class="listingblock">
<div class="content">
<pre><code># ``-l'': open a socket listening on filename
# ``-d'': argument will be taken as the target file descriptor for the
#         connection
# ``3'' : file descriptor. See ``A User's Guide to the Z-Shell''
#         (3.7.2: File descriptors)
  $ zmodload zsh/net/socket
  $ zsocket -l -d 3
# ``-a'': accept an incoming connection to the socket
  $ zsocket -a -d 4 3
  $ zsocket -a -d 5 3 # accept a connection
  $ echo foobar &gt;&amp;4
  $ echo barfoo &gt;&amp;5
  $ 4&gt;&amp;- 5&gt;&amp;- 3&gt;&amp;</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_zsh_zftp_require_zmodload_zsh_zftp">zsh/zftp (requer zmodload zsh/zftp)</h4>
<div class="listingblock">
<div class="content">
<pre><code> $ autoload -U zfinit
 $ zfinit
 $ zfparams www.example.invalid myuserid mypassword
 $ zfopen
 $ zfcd tips
 $ zfls -l zshtips.html
 $ zfput zshtips.html
 $ zfls -l zshtips.html

# Automatically transfer files using FTP with error checking
  $ autoload -U zfinit ; zfinit
  $ zftp open host.name.invalid user passwd || exit
  $ zftp get /remote/file &gt; /local/file; r=$?
  $ zftp close &amp;&amp; exit r

# compress and ftp on the fly
  $ autoload -U zfinit ; zfinit
  $ zftp open host.name.invalid user password
  $ zftp get $file | bzip2 &gt; ${file}.bz2
  $ zftp close

# Recursice ``get''
  $ autoload -U zfinit ; zfinit
  $ zfanon cr.yp.to
  $ zfcd daemontools
  $ for file in `zfls` ; do
  &gt;     zfget $file
  $ done
  $ zfclose

# Upload all regular files in $HOME/foobar (recursive) that are newer than
# two hours to ftp.foobar.invalid/path/to/upload
  $ autoload -U zfinit ; zfinit
  $ zfopen ftp.foobar.invalid/path/to/upload
  $ cd $HOME/foobar
  $ zfput -r **/*(.mh-2)
  $ zfclose

# long list of files on a ftp
  $ autoload -U zfinit ; zfinit
  $ zfopen some-host
  $ zfcd /some/remote/Dir
  $ cd /some/local/Dir
# If the list.txt is located on the remote host, change to
# zfget ${(f)"$(zftp get /path/to/remote/list.txt)"}
  $ zfget ${(f)"$(cat list.txt)"}
  $ zfclose</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_zsh_zselect_require_zmodload_zsh_zselect">zsh/zselect (requer zmodload zsh/zselect)</h4>
<div class="listingblock">
<div class="content">
<pre><code># It's similar to
 ,----
 | $ sg=$(stty -g)
 | $ stty -icanon min 0 time 50
 | $ read yesno
 | $ stty "$sg"
 | $ case "$yesno" in
 | &gt;  yes) command1;;
 | &gt;  *) command2;;
 | &gt; esac
 `----
$ zmodload zsh/zselect
$ if zselect -t 500 -r 0 &amp;&amp; read yesno &amp;&amp; [ yes = "$yesno" ]; then
&gt;    command1
&gt; else
&gt;    command1
&gt; fi</code></pre>
</div></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_options">OPÇÕES</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_navigation_options">opções de navegação</h3>
<div class="paragraph"><p><strong>auto_cd</strong> (permite que alterne de de diretório ao entrar como um comando). <strong>auto_pushd</strong> (automaticamente acrescenta diretórios a lista push/pop)
pushd_ignore_dups (e não as duplica).</p></div>
</div>
<div class="sect2">
<h3 id="_misc">Misc</h3>
<div class="paragraph"><p><strong>no_hup</strong> (não envia sinal HUP para os serviços em plano de fundo quando sair do ZSH).
<strong>print_exit_value</strong> (exibe a mensahem com o código de saída quando um comando retorna com código de saída não-zero)</p></div>
<div class="sect3">
<h4 id="_history_options">Opções de History</h4>
<div class="paragraph"><p><strong>hist_verify</strong> (permite que o usuário edite a linha de comando depois da expansão history
 (ex.: !ls) ao invés de imediatamente executá-la)<br>
Utilize o mesmo arquivo history para todas as sessões:<br>
<strong>setopt SHARE_HISTORY</strong></p></div>
</div>
<div class="sect3">
<h4 id="_privacy_security">Privacidade/Segurança</h4>
<div class="paragraph"><p><strong>no_clobber</strong>  (ou defina -C; evita que o redirecionamento <em>&gt;</em> venha a truncar o dado arquivo se ele já existe)</p></div>
</div>
<div class="sect3">
<h4 id="_spelling_correction">Correção ortográfica</h4>
<div class="paragraph"><p><strong>correct</strong> (automaticamente corrige a ortografia dos comandos).
<strong>correct_all</strong> (automaticamente corrige a ortografia de cada palavra na linha de comando) <strong>dvorak</strong> (layout dvorak)</p></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_unsorted_misc">DESORDENADO/MISCELANEA</h2>
<div class="sectionbody">
<div class="paragraph"><p>Mailpath: mailpath multiplo simples:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>mailpath=($HOME/Mail/mbox'?new mail in mbox'
          $HOME/Mail/tux.u-strasbg'?new mail in tux'
          $HOME/Mail/lilo'?new mail in lilo'
          $HOME/Mail/ldap-fr'?new mail in ldap-fr')</code></pre>
</div></div>
<div class="paragraph"><p>Mailpath: mailpath dinâmico:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>typeset -a mailpath
for i in ~/Mail/Lists/*(.); do
   mailpath[$#mailpath+1]="${i}?You have new mail in ${i:t}."
done</code></pre>
</div></div>
<div class="paragraph"><p>Evite globbing em comandos especiais:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>for com in alias expr find mattrib mcopy mdir mdel which;
alias $com="noglob $com"</code></pre>
</div></div>
<div class="paragraph"><p>Para a migração do seu prompt bash para o zsh, utilize o script bash2zshprompt localizado na distribuição de código fonte do zsh sob <em>Misc</em>.</p></div>
<div class="paragraph"><p>Para a migração do (t)csh para o zsh, utilize a ferramenta c2z que converte as alias, ambiente e variáveis shell do csh para a zsh. ele faz isso ao rodar o 
csh, e tendo o csh report nos aliases e variáveis. o script então converte esse para os arquivos de inicialização do zsh. ele possui alguns erros e informações de uso que são documentado no topo desses script.</p></div>
<div class="paragraph"><p>Aqui estão algumas funções algumas funções para configurar  o título e hardstatus de uma <strong>XTermo</strong> ou da <strong>GNU
Screen</strong> para o <em>zsh</em> e o diretório atual, respectivamente, quando o prompt for exibido, and para o nome do comando e o resto da linha de comando, respectivamente, quando um comando for executado:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>function title {
      if [[ $TERM == "screen" ]]; then
        # Use these two for GNU Screen:
        print -nR $' 33k'$1$' 33'\
        print -nR $' 33]0;'$2$''
      elif [[ $TERM == "xterm" || $TERM == "rxvt" ]]; then
        # Use this one instead for XTerms:
        print -nR $' 33]0;'$*$''
      fi
}
function precmd { title zsh "$PWD" }
function preexec {
    emulate -L zsh
    local -a cmd; cmd=(${(z)1})
    title $cmd[1]:t "$cmd[2,-1]"
}</code></pre>
</div></div>
<div class="paragraph"><p>Coloque a seguinte llinha ao seu ~/.screenrc paa visualizar esse hardstatus da hora:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>caption always "%3n %t%? (%u)%?%?: %h%?"</code></pre>
</div></div>
<div class="paragraph"><p>Variáveis especiais que são atribuídas:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$LINENO $RANDOM $SECONDS $COLUMNS $HISTCHARS $UID
$EUID $GID $EGID $USERNAME $fignore $mailpath $cdpath</code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_links">LINKS</h2>
<div class="sectionbody">
<div class="dlist"><dl>
<dt class="hdlist1">
Site primário
</dt>
<dd>
<p>
    <strong><a href="http://www.zsh.org/">http://www.zsh.org/</a></strong>
</p>
</dd>
<dt class="hdlist1">
Página do projeto</dt>
<dd>
<p>
    <strong><a href="http://sourceforge.net/projects/zsh/">http://sourceforge.net/projects/zsh/</a></strong>
</p>
</dd>
<dt class="hdlist1">
Página da Z shell na sunsite.dk
</dt>
<dd>
<p>
    <strong><a href="http://zsh.sunsite.dk/">http://zsh.sunsite.dk/</a></strong>
</p>
</dd>
<dt class="hdlist1">
Do Bash ao Z Shell: Conquistando a linha de comando - o livro
</dt>
<dd>
<p>
    <strong><a href="http://www.bash2zsh.com/">http://www.bash2zsh.com/</a></strong>
</p>
</dd>
<dt class="hdlist1">
"Zsh - die magische Shell" (livro em alemão sobre a Zsh) por Sven Guckes e Julius Plenz
</dt>
<dd>
<p>
    <strong><a href="http://zshbuch.org/">http://zshbuch.org/</a></strong>
</p>
</dd>
<dt class="hdlist1">
Mailinglistarchive
</dt>
<dd>
<p>
    <strong><a href="http://www.zsh.org/mla/">http://www.zsh.org/mla/</a></strong>
</p>
</dd>
<dt class="hdlist1">
ZSH-FAQ
</dt>
<dd>
<p>
    <strong><a href="http://zsh.dotsrc.org/FAQ/">http://zsh.dotsrc.org/FAQ/</a></strong>
</p>
</dd>
<dt class="hdlist1">
Userguide
</dt>
<dd>
<p>
    <strong><a href="http://zsh.sunsite.dk/Guide/">http://zsh.sunsite.dk/Guide/</a></strong>
</p>
</dd>
<dt class="hdlist1">
ZSH-Wiki
</dt>
<dd>
<p>
    <strong><a href="http://zshwiki.org/home/">http://zshwiki.org/home/</a></strong>
</p>
</dd>
<dt class="hdlist1">
Uma introdução rápida do BYU
</dt>
<dd>
<p>
    <strong><a href="http://docs.cs.byu.edu/linux/advanced/zsh.html">http://docs.cs.byu.edu/linux/advanced/zsh.html</a></strong>
</p>
</dd>
<dt class="hdlist1">
Suporte a Mouse ;)
</dt>
<dd>
<p>
    <strong><a href="http://stchaz.free.fr/mouse.zsh">http://stchaz.free.fr/mouse.zsh</a></strong>
</p>
</dd>
<dt class="hdlist1">
Cortinas para cima: introdução ao Z shell
</dt>
<dd>
<p>
    <strong><a href="http://www-128.ibm.com/developerworks/linux/library/l-z.html?dwzone=linux">http://www-128.ibm.com/developerworks/linux/library/l-z.html?dwzone=linux</a></strong>
</p>
</dd>
<dt class="hdlist1">
ZSH-Liebhaberseite (alemão)
</dt>
<dd>
<p>
    <strong><a href="http://michael-prokop.at/computer/tools_zsh_liebhaber.html">http://michael-prokop.at/computer/tools_zsh_liebhaber.html</a></strong>
</p>
</dd>
<dt class="hdlist1">
ZSH-Seite von Michael Prokop (alemão)
</dt>
<dd>
<p>
    <strong><a href="http://michael-prokop.at/computer/tools_zsh.html">http://michael-prokop.at/computer/tools_zsh.html</a></strong>
</p>
</dd>
<dt class="hdlist1">
Introdução ao prompt ZSH
</dt>
<dd>
<p>
    <strong><a href="http://aperiodic.net/phil/prompt/">http://aperiodic.net/phil/prompt/</a></strong>
</p>
</dd>
<dt class="hdlist1">
Configuração zsh do ft</dt>
<dd>
<p>
    <strong><a href="http://ft.bewatermyfriend.org/comp/zsh.html">http://ft.bewatermyfriend.org/comp/zsh.html</a></strong>
</p>
</dd>
<dt class="hdlist1">
Página ZSH do Adam
</dt>
<dd>
<p>
    <strong><a href="http://www.adamspiers.org/computing/zsh/">http://www.adamspiers.org/computing/zsh/</a></strong>
</p>
</dd>
<dt class="hdlist1">
Melhores dicas de Zzappers sobre a ZSH</dt>
<dd>
<p>
    <strong><a href="http://www.rayninfo.co.uk/tips/zshtips.html">http://www.rayninfo.co.uk/tips/zshtips.html</a></strong>
</p>
</dd>
<dt class="hdlist1">
Página Zsh por Christian Schneider
</dt>
<dd>
<p>
    <strong><a href="http://www.strcat.de/zsh/">http://www.strcat.de/zsh/</a></strong>
</p>
</dd>
<dt class="hdlist1">
A página amantes da zsh
</dt>
<dd>
<p>
    <strong><a href="http://grml.org/zsh/">http://grml.org/zsh/</a></strong>
</p>
</dd>
<dt class="hdlist1">
Canal IRC</dt>
<dd>
<p>
    <strong>#zsh at irc.freenode.org</strong>
</p>
</dd>
<dt class="hdlist1">
O cartão de refeência da Z shell (incluso no pacote Debian do zsh-lovers)
</dt>
<dd>
<p>
    <strong><a href="http://www.bash2zsh.com/zsh_refcard/refcard.pdf">http://www.bash2zsh.com/zsh_refcard/refcard.pdf</a></strong>
</p>
</dd>
</dl></div>
</div>
</div>
<div class="sect1">
<h2 id="_authors">AUTORES</h2>
<div class="sectionbody">
<div class="paragraph"><p>Essa manpage foi escrita por Michael Prokop, Christian <em>strcat</em>
Schneider e Matthias Kopfermann (traduzido para português do Brasil por Gabriel da Silveira Costa - AKA Toca do Tux). Mas muitas ideia tem sido retiradas do 
zsh-geeks ex. Da zsh-mailinglists (zsh-users e zsh-workers),
 do Google, dos newsgroups e da zsh-Wiki.<br>
Obrigado pela suas dicas legais e incriveis. Aprendemos muito vindo de vocês!</p></div>
<div class="paragraph"><p>Em ordem alfabética:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Andrew 'zefram' Main  - http://www.fysh.org/~zefram/
Barton E. Schaefer    - http://www.well.com/user/barts/
Matthias Kopfermann   - http://www.infodrom.north.de/~matthi/
Oliver Kiddle         - http://people.freenet.de/opk/
Paul Falstad          - http://www.falstad.com/
Peter Stephenson      - http://homepage.ntlworld.com/p.w.stephenson/
Richard Coleman
Stephane Chazelas     - http://stephane.chazelas.free.fr/
Sven Guckes           - http://www.guckes.net/
Sven Wischnowsky      - http://w9y.de/zsh/zshrc</code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_see_also">VEJA TAMBÉM</h2>
<div class="sectionbody">
<div class="paragraph"><p>Manpages da zsh:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>       zsh          Visão geral da Zsh
       zshall       A meta man page da Z shell
       zshbuiltins  Comandos built-in da Zsh
       zshcalsys    zsh sistema de calendário
       zshcompctl   zsh programmable completion
       zshcompsys   Zsh completion system
       zshcompwid   Zsh completion widgets
       zshcontrib   User contributions to zsh
       zshexpn      Zsh expansion and substitution
       zshmisc      Anything not fitting into the other sections
       zshmodules   Zsh loadable modules
       zshoptions   Zsh options
       zshparam     Zsh parameters
       zshroadmap   Informal introduction to the zsh manual
       zshtcpsys    Zsh tcp system
       zshzle       Zsh command line editing
       zshzftpsys   Zsh built-in FTP client
       zshall       Meta-man page containing all of the above</code></pre>
</div></div>
<div class="paragraph"><p>Nota: Especialmente <em>man zshcontrib</em> cobre tópicos muito úteis!<br>Livro: <strong>From Bash to Z Shell</strong> por Oliver Kiddle, Jerry Peck e Peter
Stephenson. <strong>ISBN: 1590593766</strong>. - <strong><a href="http://www.bash2zsh.com/">bash2zsh.com</a></strong><br>
Dê uma olhada também na seção <strong>LINKS</strong> nessa manpage.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_bugs">BUGS</h2>
<div class="sectionbody">
<div class="paragraph"><p>Provavelmente. Essa manpage pode nunca estar completa. Então, por favor, reporte os bugs,
feedback e sugestões para &lt;<a href="mailto:zsh-lovers@michael-prokop.at">zsh-lovers@michael-prokop.at</a>&gt;. Obrigado!</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_copyright">COPYRIGHT</h2>
<div class="sectionbody">
<div class="paragraph"><p>Copyright  (C) Michael Prokop, Christian Schneider e Matthias
Kopfermann.</p></div>
</div>
</div>
</div>

<div id="footer">
<div id="footer-text">
Last updated 2010-07-28 21:55:37 UTC
</div>
</div>


</body></html>